# -*- coding: utf-8 -*-
"""Copy of final Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jI2WK1Pq_U8zBX7NDXKUTuQlAFQQSypt
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pickle

data = pd.read_csv('/content/Training.csv')

data.head()

data.isnull().sum()

data.info()

data.describe()

data.shape

data.drop(['Unnamed: 133'] , axis = 1 , inplace = True )

data.prognosis.value_counts()

data.columns

dict1 = {'Fungal infection':0,'Allergy':1,'GERD':2,'Chronic cholestasis':3,'Drug Reaction':4,'Peptic ulcer diseae':5,
                         'AIDS':6,'Diabetes ':7,'Gastroenteritis':8,'Bronchial Asthma':9,'Hypertension ':10,'Migraine':11,'Cervical spondylosis':12,
                         'Paralysis (brain hemorrhage)':13,'Jaundice':14,'Malaria':15,'Chicken pox':16,'Dengue':17,'Typhoid':18,'hepatitis A':19,'Hepatitis B':20,
                         'Hepatitis C':21,'Hepatitis D':22,'Hepatitis E':23,'Alcoholic hepatitis':24,'Tuberculosis':25,
                         'Common Cold':26,'Pneumonia':27,'Dimorphic hemmorhoids(piles)':28,'Heart attack':29,'Varicose veins':30,'Hypothyroidism':31,
                         'Hyperthyroidism':32,'Hypoglycemia':33,'Osteoarthristis':34,'Arthritis':35,'(vertigo) Paroymsal  Positional Vertigo':36,
                         'Acne':37,'Urinary tract infection':38,'Psoriasis':39,'Impetigo':40}
data.replace({'prognosis':dict1},inplace=True)

import random
def fun(arr):
  idx = []
  for i in range(len(arr)):
    if arr[i] == 1:
      idx.append(i)
  count = 0
  if len(idx) >=5:
    count = len(idx) - 5

  lst = random.sample(idx,count)
  for i in lst:
    arr[i] = 0

  return arr

X = data.iloc[:,:131].values
Y = data.iloc[:,-1].values

from sklearn.model_selection import train_test_split
x_train,x_dev,y_train,y_dev = train_test_split(X,Y,test_size = 0.3 , random_state = 42)

test_data = pd.read_csv('/content/Testing (1).csv')
test_data.replace({'prognosis':dict1},inplace=True)
x_test = test_data.iloc[:,:131].values
y_test = test_data.iloc[:,-1].values
for i in range(x_test.shape[0]):
  x_test[i,:] = fun(x_test[i,:])

from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

models = {'LogisticRegression':LogisticRegression(),
          'KNeighborsClassifier':KNeighborsClassifier(),
          'Support Vector Classifier' : SVC(),
          'GaussianNB' : GaussianNB(),
          'DecisionTreeClassifier' : DecisionTreeClassifier(),
          'RandomForestClassifier' : RandomForestClassifier(),
          'XGBClassifier' : XGBClassifier()}

for i in range(x_dev.shape[0]):
  x_dev[i,:] = fun(x_dev[i,:])

from sklearn.metrics import accuracy_score,f1_score


for i in models.keys():
  model = models[i]
  model.fit(x_train,y_train)
  y_pred_dev = model.predict(x_dev)
  y_pred = model.predict(x_test)
  print('model',':',i)
  print('Dev Accuracy : ',accuracy_score(y_dev,y_pred_dev)*100,'%')
  print('test Accuracy : ',accuracy_score(y_test,y_pred)*100,'%')

  print("")

from sklearn.model_selection import RandomizedSearchCV

n_estimators = [int(x) for x in np.linspace(start = 300, stop = 600, num = 50)]
max_features = ['auto', 'sqrt']
max_depth = [int(x) for x in np.linspace(10, 110, num = 11)]
max_depth.append(None)
min_samples_split = [3,4,5, 10]
min_samples_leaf = [1, 2, 4]
bootstrap = [True, False]
random_grid = {'n_estimators': n_estimators,
               'max_features': max_features,
               'max_depth': max_depth,
               'min_samples_split': min_samples_split,
               'min_samples_leaf': min_samples_leaf,
               'bootstrap': bootstrap}
rf = RandomForestClassifier()
rf_random = RandomizedSearchCV(estimator = rf, param_distributions = random_grid, n_iter = 100, cv = 3, verbose=2, random_state=42, n_jobs = -1)
rf_random.fit(x_train, y_train)
print(rf_random.best_params_)

print(rf_random.best_params_)
preds = rf_random.best_estimator_.predict(x_dev)

print('Dev set Accuracy : ',accuracy_score(y_dev,preds)*100,'%')

test_y_pred = rf_random.best_estimator_.predict(x_test)

print('test set Accuracy : ',accuracy_score(y_test,test_y_pred)*100,'%')

filename = 'Multiple_disease_prediction_rf.pkl'
pickle.dump(models['RandomForestClassifier'] ,open(filename , 'wb'))

columns_dict = {}
columns_list = data.columns.tolist()
for i in range(len(columns_list)):
  columns_dict[columns_list[i]] = i

columns_dict

predict_ans = {}
for i in dict1:
  predict_ans[dict1[i]] = i

predict_ans

def generate_input(selected_options ,columns_dict ):
  new_input = np.zeros((1,x_train.shape[1]))
  for i in selected_options:
    new_input[0][columns_dict[i]] = 1

  return new_input

from flask import Flask,render_template,request
import pickle
import numpy as np

model = pickle.load(open('Multiple_disease_prediction_rf.pkl','rb'))
app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/predict',methods=['POST'])
def predict_placement():
    selected_options =  request.body.options

    new_input =  generate_input(selected_options ,columns_dict )

    # prediction
    result = model.predict(new_input)

    return predict_ans[result];


if __name__ == '__main__':
    app.run(host='0.0.0.0',port=8080)

